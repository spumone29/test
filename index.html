<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Vertical Dodge Defense</title>
<style>
:root {
  --bg: #ffffff;
  --fg: #0f1115;
  --muted: #5b6371;
  --accent: #2563eb;
  --accent-strong: #1d4ed8;
  --panel-bg: rgba(255, 255, 255, 0.72);
  --panel-border: rgba(15, 17, 21, 0.12);
  --panel-shadow: 0 20px 45px rgba(15, 17, 21, 0.08);
  --canvas-bg: #ffffff;
  --flash-color: rgba(255, 255, 255, 0.65);
  --hit-color: rgba(247, 62, 62, 0.32);
}
[data-theme="dark"] {
  --bg: #0b0f1a;
  --fg: #e4e9f7;
  --muted: #99a2ba;
  --accent: #38bdf8;
  --accent-strong: #0ea5e9;
  --panel-bg: rgba(14, 19, 35, 0.78);
  --panel-border: rgba(232, 237, 255, 0.12);
  --panel-shadow: 0 18px 40px rgba(5, 10, 24, 0.6);
  --canvas-bg: #030712;
  --flash-color: rgba(255, 255, 255, 0.55);
  --hit-color: rgba(251, 113, 133, 0.35);
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  min-height: 100vh;
  font-family: "Segoe UI", "Roboto", sans-serif;
  background: var(--bg);
  color: var(--fg);
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 24px clamp(12px, 4vw, 48px) 48px;
  gap: 20px;
}
h1 {
  margin: 0;
  font-size: clamp(1.4rem, 2vw, 1.9rem);
  letter-spacing: 0.04em;
  text-transform: uppercase;
  color: var(--muted);
}
.game-shell {
  width: min(100%, 1100px);
  display: flex;
  flex-direction: column;
  gap: 16px;
  align-items: center;
}
.panel {
  width: 100%;
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: 16px;
  box-shadow: var(--panel-shadow);
  backdrop-filter: blur(16px);
  padding: clamp(12px, 3vw, 20px);
  display: flex;
  flex-wrap: wrap;
  gap: 12px 18px;
  align-items: center;
  justify-content: center;
}
.panel h2 {
  display: none;
}
.hud-item {
  font-size: clamp(0.9rem, 1.6vw, 1.05rem);
  font-weight: 600;
  color: var(--fg);
  display: flex;
  gap: 6px;
  align-items: center;
}
.hud-item span {
  color: var(--accent);
}
button,
select {
  font: inherit;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 999px;
  padding: 10px 18px;
  cursor: pointer;
  transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
  box-shadow: 0 10px 22px rgba(37, 99, 235, 0.24);
}
button:hover,
select:hover {
  transform: translateY(-1px);
  box-shadow: 0 14px 28px rgba(37, 99, 235, 0.28);
}
button:active {
  transform: translateY(1px);
}
button.secondary {
  background: transparent;
  color: var(--accent);
  border: 1px solid var(--accent);
  box-shadow: none;
}
select {
  appearance: none;
  padding: 10px 42px 10px 16px;
  position: relative;
  background: var(--panel-bg);
  color: var(--fg);
  border: 1px solid var(--panel-border);
  box-shadow: none;
}
.select-wrap {
  position: relative;
}
.select-wrap::after {
  content: "▾";
  position: absolute;
  right: 14px;
  top: 50%;
  transform: translateY(-55%);
  color: var(--muted);
  pointer-events: none;
}
canvas {
  display: block;
  width: 100%;
  background: var(--canvas-bg);
  border-radius: 18px;
  border: 1px solid rgba(0, 0, 0, 0.08);
  max-height: 78vh;
}
.overlay,
.modal {
  position: fixed;
  inset: 0;
  background: rgba(6, 10, 20, 0.72);
  backdrop-filter: blur(12px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  padding: 24px;
}
.card {
  width: min(100%, 420px);
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: 22px;
  box-shadow: var(--panel-shadow);
  padding: 30px clamp(18px, 4vw, 36px);
  display: flex;
  flex-direction: column;
  gap: 18px;
  text-align: center;
}
.card h3 {
  margin: 0;
  font-size: clamp(1.2rem, 2vw, 1.5rem);
}
.card p {
  margin: 0;
  color: var(--muted);
  line-height: 1.45;
  font-size: 0.95rem;
}
.hidden {
  display: none !important;
}
.controls {
  gap: 12px;
}
.controls .select-wrap,
.controls button {
  flex: 0 1 auto;
}
.status-note {
  font-size: 0.85rem;
  color: var(--muted);
}
@media (max-width: 768px) {
  .panel {
    justify-content: stretch;
  }
  .hud-item {
    flex: 1 1 calc(50% - 18px);
  }
  .controls {
    flex-direction: column;
  }
  .controls button,
  .select-wrap {
    width: 100%;
  }
  button,
  select {
    width: 100%;
    text-align: center;
  }
}
</style>
</head>
<body>
<h1>Vertical Dodge Defense</h1>
<div class="game-shell">
  <section class="panel hud">
    <div class="hud-item">Score: <span id="scoreValue">0</span></div>
    <div class="hud-item">Lives: <span id="livesValue">3</span></div>
    <div class="hud-item">Difficulty: <span id="difficultyValue">Normal</span></div>
    <div class="hud-item">Best: <span id="bestValue">0</span></div>
    <button id="pauseBtn" class="secondary">Pause</button>
    <button id="muteBtn" class="secondary">Mute</button>
  </section>

  <section class="panel controls">
    <div class="select-wrap">
      <select id="difficultySelect" title="Difficulty">
        <option value="easy">Easy</option>
        <option value="normal" selected>Normal</option>
        <option value="hard">Hard</option>
      </select>
    </div>
    <button id="restartBtn" type="button">Restart</button>
    <button id="darkModeToggle" type="button" class="secondary">Dark Mode: Off</button>
  </section>

  <canvas id="gameCanvas" width="1280" height="720">Your browser does not support the HTML5 canvas.</canvas>
  <p class="status-note">Move with mouse/touch or A/D / Arrow keys. Avoid falling logos. Space to pause, R to restart.</p>
</div>

<div id="startOverlay" class="overlay">
  <div class="card">
    <h3 id="startTitle">Loading Assets…</h3>
    <p id="startMessage">Please hold on while sprites are prepared.</p>
    <button id="startBtn" type="button" disabled>Click or Tap to Start</button>
  </div>
</div>

<div id="gameOverModal" class="modal hidden">
  <div class="card">
    <h3>Game Over</h3>
    <p>Final Score: <span id="finalScore">0</span></p>
    <p>Best Score (<span id="bestDifficultyLabel">Normal</span>): <strong id="bestHighScore">0</strong></p>
    <button id="modalRestartBtn" type="button">Play Again</button>
  </div>
</div>

<script>
(() => {
  "use strict";

  const PLAYFIELD_HEIGHT = 720;
  const PLAYER_SAFE_MARGIN = 56;
  const PLAYER_BASE_WIDTH = 112;
  const KEYBOARD_SPEED = 620;
  const FOLLOW_FACTOR = 12;
  const INVULN_DURATION = 1.2;
  const HIT_FLASH_DURATION = 0.25;
  const LS_PREFIX = "smGame_bestScore_";

  const PLAYER_SRC = "img/icn-bank-shinhan.png";
  const ENEMY_SOURCES = [
    "img/icn-bank-acuonsb.png",
    "img/icn-bank-bac.png",
    "img/icn-bank-bankofchina.png",
    "img/icn-bank-bnk.png",
    "img/icn-bank-bnp.png",
    "img/icn-bank-bookook.png",
    "img/icn-bank-cape.png",
    "img/icn-bank-chinaconstruction.png",
    "img/icn-bank-citi.png",
    "img/icn-bank-cu.png",
    "img/icn-bank-daishin.png",
    "img/icn-bank-daolbank.png",
    "img/icn-bank-db.png",
    "img/icn-bank-deutsche.png",
    "img/icn-bank-dgb.png",
    "img/icn-bank-ebest.png",
    "img/icn-bank-eugeneinvest.png",
    "img/icn-bank-fosskorea.png",
    "img/icn-bank-hana.png",
    "img/icn-bank-hanhwa.png",
    "img/icn-bank-hb.png",
    "img/icn-bank-horizontal-kbank (1).png",
    "img/icn-bank-horizontal-kbank.png",
    "img/icn-bank-horizontal-lottecard.png",
    "img/icn-bank-horizontal-shinhancard.png",
    "img/icn-bank-hsbc.png",
    "img/icn-bank-hyundaicapital.png",
    "img/icn-bank-hyundaicar.png",
    "img/icn-bank-hyundaicard.png",
    "img/icn-bank-ibk.png",
    "img/icn-bank-icbc.png",
    "img/icn-bank-jb.png",
    "img/icn-bank-jpmorgan.png",
    "img/icn-bank-jtbank.png",
    "img/icn-bank-jtchinae.png",
    "img/icn-bank-kakao.png",
    "img/icn-bank-kb.png",
    "img/icn-bank-kdb.png",
    "img/icn-bank-kium.png",
    "img/icn-bank-kiwoom.png",
    "img/icn-bank-korea-investment.png",
    "img/icn-bank-koreaexim.png",
    "img/icn-bank-koreasset.png",
    "img/icn-bank-ktb.png",
    "img/icn-bank-kwangju.png",
    "img/icn-bank-kyobo.png",
    "img/icn-bank-leading.png",
    "img/icn-bank-leadingkakaopaysecurity.png",
    "img/icn-bank-lottecapital.png",
    "img/icn-bank-meritz.png",
    "img/icn-bank-mg.png",
    "img/icn-bank-miraeasset.png",
    "img/icn-bank-moaloan.png",
    "img/icn-bank-nfcf.png",
    "img/icn-bank-nh.png",
    "img/icn-bank-ok.png",
    "img/icn-bank-pepper-oval.png",
    "img/icn-bank-postoffice.png",
    "img/icn-bank-samsung-texttype.png",
    "img/icn-bank-samsungcard.png",
    "img/icn-bank-sb.png",
    "img/icn-bank-sc.png",
    "img/icn-bank-shinhan.png",
    "img/icn-bank-shinyoung.png",
    "img/icn-bank-sk.png",
    "img/icn-bank-suhyup.png",
    "img/icn-bank-toss-logo.png",
    "img/icn-bank-welcomesavings.png",
    "img/icn-bank-woori.png",
    "img/icn-bank-wooricard.png",
    "img/icn-bank-yegaramsb.png",
    "img/icn-bank-yuanta.png"
  ];
  const FALLBACK_COLORS = ["#f97316", "#22c55e", "#38bdf8", "#e11d48", "#a855f7", "#facc15", "#fb7185"];

  const difficultyNames = { easy: "Easy", normal: "Normal", hard: "Hard" };
  const DIFFICULTIES = {
    easy:   { spawnInterval: 1.2, minSpawn: 0.55, spawnDecrease: 0.003, baseSpeed: 180, speedRamp: 1.8 },
    normal: { spawnInterval: 0.92, minSpawn: 0.38, spawnDecrease: 0.004, baseSpeed: 220, speedRamp: 2.4 },
    hard:   { spawnInterval: 0.72, minSpawn: 0.28, spawnDecrease: 0.0055, baseSpeed: 260, speedRamp: 3.1 }
  };

  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d", { alpha: false });
  const scoreEl = document.getElementById("scoreValue");
  const livesEl = document.getElementById("livesValue");
  const difficultyEl = document.getElementById("difficultyValue");
  const bestEl = document.getElementById("bestValue");
  const pauseBtn = document.getElementById("pauseBtn");
  const muteBtn = document.getElementById("muteBtn");
  const restartBtn = document.getElementById("restartBtn");
  const modalRestartBtn = document.getElementById("modalRestartBtn");
  const difficultySelect = document.getElementById("difficultySelect");
  const darkModeToggle = document.getElementById("darkModeToggle");
  const startOverlay = document.getElementById("startOverlay");
  const startBtn = document.getElementById("startBtn");
  const startTitle = document.getElementById("startTitle");
  const startMessage = document.getElementById("startMessage");
  const gameOverModal = document.getElementById("gameOverModal");
  const finalScoreEl = document.getElementById("finalScore");
  const bestDifficultyLabel = document.getElementById("bestDifficultyLabel");
  const bestHighScoreEl = document.getElementById("bestHighScore");

  const state = {
    running: false,
    paused: false,
    ready: false,
    gameOver: false,
    score: 0,
    lives: 3,
    difficulty: "normal",
    bestScores: { easy: 0, normal: 0, hard: 0 },
    playerX: 0,
    playerY: PLAYFIELD_HEIGHT - PLAYER_SAFE_MARGIN,
    playerWidth: PLAYER_BASE_WIDTH,
    playerHeight: Math.round(PLAYER_BASE_WIDTH * 0.7),
    playerHasSprite: false,
    targetX: 0,
    keyboardDir: 0,
    enemies: [],
    enemyPool: [],
    spawnTimer: 0,
    currentSpawnInterval: DIFFICULTIES.normal.spawnInterval,
    elapsed: 0,
    invulnTimer: 0,
    hitFlashTimer: 0,
    playfieldWidth: 0,
    dpr: window.devicePixelRatio || 1,
    lastTime: performance.now(),
    canvasBg: "#0c152d",
    flashColor: "rgba(255,255,255,0.65)",
    hitColor: "rgba(247, 62, 62, 0.32)",
    pointerActive: false
  };

  const playerImage = new Image();
  const enemySprites = ENEMY_SOURCES.map(src => ({
    src,
    image: new Image(),
    loaded: false,
    ratio: 1
  }));

  const pressedKeys = new Set();
  const audio = { context: null, muted: false };

  function loadImage(image, src) {
    return new Promise(resolve => {
      image.onload = () => resolve({ success: true });
      image.onerror = () => {
        console.warn(`Asset missing: ${src}`);
        resolve({ success: false });
      };
      image.src = src;
    });
  }

  async function preloadAssets() {
    const playerResult = await loadImage(playerImage, PLAYER_SRC);
    if (playerResult.success && playerImage.naturalWidth) {
      state.playerHasSprite = true;
      const ratio = playerImage.naturalHeight / playerImage.naturalWidth;
      state.playerHeight = Math.round(state.playerWidth * ratio);
    }
    await Promise.all(enemySprites.map(async sprite => {
      const result = await loadImage(sprite.image, sprite.src);
      sprite.loaded = result.success;
      sprite.ratio = (sprite.loaded && sprite.image.naturalWidth)
        ? sprite.image.naturalHeight / sprite.image.naturalWidth
        : 1;
    }));
  }

  function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }

  function refreshThemeCache() {
    const styles = getComputedStyle(document.body);
    state.canvasBg = styles.getPropertyValue("--canvas-bg").trim() || "#0c152d";
    state.flashColor = styles.getPropertyValue("--flash-color").trim() || "rgba(255,255,255,0.65)";
    state.hitColor = styles.getPropertyValue("--hit-color").trim() || "rgba(247, 62, 62, 0.32)";
  }

  function handleResize() {
    const rect = canvas.getBoundingClientRect();
    const width = rect.width || canvas.clientWidth || 800;
    state.playfieldWidth = width;
    state.dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(width * state.dpr);
    canvas.height = Math.round(PLAYFIELD_HEIGHT * state.dpr);
    canvas.style.width = "100%";
    state.playerY = PLAYFIELD_HEIGHT - PLAYER_SAFE_MARGIN - state.playerHeight / 2;
    state.playerX = clamp(state.playerX || width / 2, state.playerWidth / 2, width - state.playerWidth / 2);
    state.targetX = clamp(state.targetX || width / 2, state.playerWidth / 2, width - state.playerWidth / 2);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }

  function resetState() {
    const cfg = DIFFICULTIES[state.difficulty];
    state.score = 0;
    state.lives = 3;
    state.enemies.length = 0;
    state.spawnTimer = cfg.spawnInterval;
    state.currentSpawnInterval = cfg.spawnInterval;
    state.elapsed = 0;
    state.invulnTimer = 0;
    state.hitFlashTimer = 0;
    state.gameOver = false;
    state.playerX = state.playfieldWidth / 2 || canvas.width / (state.dpr * 2);
    state.targetX = state.playerX;
  }

  function updateHud() {
    scoreEl.textContent = state.score;
    livesEl.textContent = state.lives;
    difficultyEl.textContent = difficultyNames[state.difficulty];
    bestEl.textContent = state.bestScores[state.difficulty] || 0;
    pauseBtn.textContent = state.paused ? "Resume" : "Pause";
    muteBtn.textContent = audio.muted ? "Unmute" : "Mute";
    darkModeToggle.textContent = document.body.dataset.theme === "dark" ? "Dark Mode: On" : "Dark Mode: Off";
  }

  function ensureBestLoaded() {
    try {
      Object.keys(DIFFICULTIES).forEach(key => {
        const stored = localStorage.getItem(LS_PREFIX + key);
        if (stored) {
          const parsed = parseInt(stored, 10);
          if (!Number.isNaN(parsed)) {
            state.bestScores[key] = parsed;
          }
        }
      });
    } catch (err) {
      console.warn("Unable to access localStorage.", err);
    }
  }

  function persistBest() {
    const current = state.bestScores[state.difficulty] || 0;
    if (state.score > current) {
      state.bestScores[state.difficulty] = state.score;
      try {
        localStorage.setItem(LS_PREFIX + state.difficulty, String(state.score));
      } catch (err) {
        console.warn("Unable to store best score.", err);
      }
    }
  }

  function spawnEnemy() {
    const cfg = DIFFICULTIES[state.difficulty];
    const baseWidth = 76;
    const sprite = enemySprites[Math.floor(Math.random() * enemySprites.length)];
    const enemy = state.enemyPool.pop() || {};
    const width = baseWidth;
    const ratio = sprite.loaded ? sprite.ratio : 1;
    enemy.width = width;
    enemy.height = Math.max(48, width * ratio);
    enemy.x = clamp(Math.random() * (state.playfieldWidth - enemy.width) + enemy.width / 2,
      enemy.width / 2, state.playfieldWidth - enemy.width / 2);
    enemy.y = -enemy.height / 2;
    enemy.speed = cfg.baseSpeed + state.elapsed * cfg.speedRamp;
    enemy.sprite = sprite;
    enemy.loaded = sprite.loaded;
    enemy.color = FALLBACK_COLORS[Math.floor(Math.random() * FALLBACK_COLORS.length)];
    state.enemies.push(enemy);
  }

  function recycleEnemy(index) {
    const removed = state.enemies.splice(index, 1)[0];
    if (removed) {
      state.enemyPool.push(removed);
    }
  }

  function handleHit() {
    if (state.invulnTimer > 0) return;
    state.lives -= 1;
    state.invulnTimer = INVULN_DURATION;
    state.hitFlashTimer = HIT_FLASH_DURATION;
    playTone(220, 0.18, "square", 0.3);
    if (state.lives <= 0) {
      triggerGameOver();
    }
    updateHud();
  }

  function unlockAudio() {
    if (audio.context || audio.muted) return;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (!Ctx) return;
    audio.context = new Ctx();
    if (audio.context.state === "suspended") {
      audio.context.resume().catch(() => {});
    }
  }

  function playTone(freq, duration = 0.1, type = "sine", gainValue = 0.25) {
    if (!audio.context || audio.muted) return;
    try {
      const now = audio.context.currentTime;
      const osc = audio.context.createOscillator();
      const gain = audio.context.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, now);
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(gainValue, now + 0.01);
      gain.gain.linearRampToValueAtTime(0, now + duration);
      osc.connect(gain);
      gain.connect(audio.context.destination);
      osc.start(now);
      osc.stop(now + duration + 0.05);
    } catch (err) {
      console.warn("Audio playback failed.", err);
    }
  }

  function triggerGameOver() {
    persistBest();
    state.gameOver = true;
    state.running = false;
    state.paused = true;
    updateHud();
    finalScoreEl.textContent = state.score;
    bestDifficultyLabel.textContent = difficultyNames[state.difficulty];
    bestHighScoreEl.textContent = state.bestScores[state.difficulty] || state.score;
    gameOverModal.classList.remove("hidden");
    playTone(140, 0.5, "sawtooth", 0.4);
  }

  function setDifficulty(diff) {
    if (!DIFFICULTIES[diff]) return;
    state.difficulty = diff;
    difficultySelect.value = diff;
    updateHud();
  }

  function setPaused(forceValue) {
    if (!state.running) return;
    const next = typeof forceValue === "boolean" ? forceValue : !state.paused;
    state.paused = next;
    if (!next) {
      state.lastTime = performance.now();
    }
    updateHud();
  }

  function restartGame(resume = true) {
    state.running = resume;
    state.paused = !resume;
    state.gameOver = false;
    gameOverModal.classList.add("hidden");
    resetState();
    updateHud();
    if (resume) {
      state.lastTime = performance.now();
    }
  }

  function startGame() {
    if (!state.ready) return;
    unlockAudio();
    restartGame(true);
    state.running = true;
    state.paused = false;
    startOverlay.classList.add("hidden");
    updateHud();
  }

  function handlePointer(clientX) {
    const rect = canvas.getBoundingClientRect();
    if (!rect.width) return;
    const ratio = (clientX - rect.left) / rect.width;
    const target = ratio * state.playfieldWidth;
    state.targetX = clamp(target, state.playerWidth / 2, state.playfieldWidth - state.playerWidth / 2);
  }

  function updateKeyboardDir() {
    const left = pressedKeys.has("ArrowLeft") || pressedKeys.has("KeyA");
    const right = pressedKeys.has("ArrowRight") || pressedKeys.has("KeyD");
    state.keyboardDir = (right ? 1 : 0) - (left ? 1 : 0);
  }

  function updateGame(dt) {
    const cfg = DIFFICULTIES[state.difficulty];
    state.elapsed += dt;
    state.currentSpawnInterval = Math.max(cfg.minSpawn, cfg.spawnInterval - state.elapsed * cfg.spawnDecrease);
    state.spawnTimer -= dt;
    while (state.spawnTimer <= 0) {
      spawnEnemy();
      state.spawnTimer += state.currentSpawnInterval;
    }

    if (state.keyboardDir !== 0) {
      state.targetX = clamp(
        state.targetX + state.keyboardDir * KEYBOARD_SPEED * dt,
        state.playerWidth / 2,
        state.playfieldWidth - state.playerWidth / 2
      );
    }

    const diff = state.targetX - state.playerX;
    state.playerX += diff * Math.min(1, dt * FOLLOW_FACTOR);
    state.playerX = clamp(state.playerX, state.playerWidth / 2, state.playfieldWidth - state.playerWidth / 2);

    if (state.invulnTimer > 0) state.invulnTimer = Math.max(0, state.invulnTimer - dt);
    if (state.hitFlashTimer > 0) state.hitFlashTimer = Math.max(0, state.hitFlashTimer - dt);

    for (let i = state.enemies.length - 1; i >= 0; i -= 1) {
      const enemy = state.enemies[i];
      enemy.y += enemy.speed * dt;
      if (enemy.y - enemy.height / 2 > PLAYFIELD_HEIGHT) {
        recycleEnemy(i);
        state.score += 1;
        persistBest();
        updateHud();
        playTone(660, 0.06, "triangle", 0.18);
        continue;
      }
      if (state.invulnTimer <= 0) {
        const overlapX = Math.abs(state.playerX - enemy.x) < (state.playerWidth + enemy.width) / 2;
        const overlapY = Math.abs(state.playerY - enemy.y) < (state.playerHeight + enemy.height) / 2;
        if (overlapX && overlapY) {
          recycleEnemy(i);
          handleHit();
        }
      }
    }
  }

  function drawBackground() {
    ctx.fillStyle = state.canvasBg;
    ctx.fillRect(0, 0, state.playfieldWidth, PLAYFIELD_HEIGHT);

    const gradient = ctx.createLinearGradient(0, 0, 0, PLAYFIELD_HEIGHT);
    gradient.addColorStop(0, "rgba(255,255,255,0.04)");
    gradient.addColorStop(1, "rgba(0,0,0,0.22)");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, state.playfieldWidth, PLAYFIELD_HEIGHT);
  }

  function drawPlayer(time) {
    ctx.save();
    const blink = state.invulnTimer > 0 && Math.floor(time * 10) % 2 === 0;
    if (blink) ctx.globalAlpha = 0.4;
    const x = state.playerX - state.playerWidth / 2;
    const y = state.playerY - state.playerHeight / 2;
    if (state.playerHasSprite) {
      ctx.drawImage(playerImage, x, y, state.playerWidth, state.playerHeight);
    } else {
      ctx.fillStyle = "#60a5fa";
      ctx.fillRect(x, y, state.playerWidth, state.playerHeight);
    }
    ctx.restore();
  }

  function drawEnemies() {
    for (const enemy of state.enemies) {
      const x = enemy.x - enemy.width / 2;
      const y = enemy.y - enemy.height / 2;
      if (enemy.loaded) {
        ctx.drawImage(enemy.sprite.image, x, y, enemy.width, enemy.height);
      } else {
        ctx.fillStyle = enemy.color || "rgba(255,255,255,0.4)";
        ctx.fillRect(x, y, enemy.width, enemy.height);
      }
    }
  }

  function drawOverlays() {
    if (state.hitFlashTimer > 0) {
      ctx.fillStyle = state.hitColor;
      ctx.fillRect(0, 0, state.playfieldWidth, PLAYFIELD_HEIGHT);
    }
    if (state.paused && state.running && !state.gameOver) {
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(0, 0, state.playfieldWidth, PLAYFIELD_HEIGHT);
      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 36px 'Segoe UI', sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Paused", state.playfieldWidth / 2, PLAYFIELD_HEIGHT / 2);
    }
    if (!state.running && !state.gameOver && state.ready) {
      ctx.fillStyle = "rgba(0,0,0,0.28)";
      ctx.fillRect(0, 0, state.playfieldWidth, PLAYFIELD_HEIGHT);
      ctx.fillStyle = "#ffffff";
      ctx.font = "600 24px 'Segoe UI', sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Click or tap Start to begin", state.playfieldWidth / 2, PLAYFIELD_HEIGHT / 2);
    }
  }

  function draw(timestamp) {
    ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);

    drawBackground();
    drawEnemies();
    drawPlayer(timestamp / 1000);
    if (state.hitFlashTimer > 0) {
      ctx.fillStyle = state.flashColor;
      ctx.globalAlpha = state.hitFlashTimer / HIT_FLASH_DURATION;
      ctx.fillRect(0, 0, state.playfieldWidth, PLAYFIELD_HEIGHT);
      ctx.globalAlpha = 1;
    }
    drawOverlays();
  }

  function gameLoop(timestamp) {
    const delta = Math.min(0.12, (timestamp - state.lastTime) / 1000);
    state.lastTime = timestamp;
    if (state.running && !state.paused) {
      updateGame(delta);
    }
    draw(timestamp);
    requestAnimationFrame(gameLoop);
  }

  function bindEvents() {
    window.addEventListener("resize", () => {
      handleResize();
    });

    window.addEventListener("keydown", event => {
      if (event.code === "ArrowLeft" || event.code === "ArrowRight" || event.code === "KeyA" || event.code === "KeyD") {
        event.preventDefault();
        pressedKeys.add(event.code);
        updateKeyboardDir();
      }
      if (event.code === "Space") {
        event.preventDefault();
        setPaused();
      }
      if (event.code === "KeyR") {
        event.preventDefault();
        restartGame(true);
      }
    });

    window.addEventListener("keyup", event => {
      if (pressedKeys.has(event.code)) {
        pressedKeys.delete(event.code);
        updateKeyboardDir();
      }
    });

    canvas.addEventListener("pointerdown", e => {
      state.pointerActive = true;
      unlockAudio();
      handlePointer(e.clientX);
    });

    canvas.addEventListener("pointermove", e => {
      if (state.pointerActive) {
        handlePointer(e.clientX);
      }
    });

    window.addEventListener("pointerup", () => {
      state.pointerActive = false;
    });

    canvas.addEventListener("touchstart", e => {
      unlockAudio();
      if (e.changedTouches[0]) {
        handlePointer(e.changedTouches[0].clientX);
        e.preventDefault();
      }
    }, { passive: false });

    canvas.addEventListener("touchmove", e => {
      if (e.changedTouches[0]) {
        handlePointer(e.changedTouches[0].clientX);
        e.preventDefault();
      }
    }, { passive: false });

    pauseBtn.addEventListener("click", () => setPaused());
    muteBtn.addEventListener("click", () => {
      audio.muted = !audio.muted;
      if (!audio.muted) unlockAudio();
      updateHud();
    });
    restartBtn.addEventListener("click", () => restartGame(true));
    modalRestartBtn.addEventListener("click", () => {
      gameOverModal.classList.add("hidden");
      restartGame(true);
      state.running = true;
      state.paused = false;
    });

    difficultySelect.addEventListener("change", () => {
      setDifficulty(difficultySelect.value);
      restartGame(true);
    });

    darkModeToggle.addEventListener("click", () => {
      const nextTheme = document.body.dataset.theme === "dark" ? "" : "dark";
      if (nextTheme) {
        document.body.dataset.theme = "dark";
      } else {
        delete document.body.dataset.theme;
      }
      refreshThemeCache();
      updateHud();
    });

    startBtn.addEventListener("click", startGame);

    document.addEventListener("visibilitychange", () => {
      if (document.hidden && state.running && !state.paused) {
        setPaused(true);
      }
    });
  }

  async function init() {
    refreshThemeCache();
    ensureBestLoaded();
    updateHud();
    handleResize();
    bindEvents();

    await preloadAssets();
    state.ready = true;
    startTitle.textContent = "Click or Tap to Start";
    startMessage.textContent = "Move horizontally to dodge falling enemies. Survive for the highest score!";
    startBtn.disabled = false;
    updateHud();
    gameLoop(performance.now());
  }

  init();
})();
</script>
</body>
</html>
